import { NextRequest, NextResponse } from 'next/server';
import crypto from 'crypto';

// Fun√ß√£o para verificar a assinatura do webhook
function verifyWebhookSignature(payload: string, signature: string, secret: string): boolean {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(signature, 'hex'),
    Buffer.from(expectedSignature, 'hex')
  );
}

// Fun√ß√£o para processar diferentes tipos de eventos
async function processWebhookEvent(eventType: string, data: any) {
  console.log(`Processando evento: ${eventType}`, data);

  switch (eventType) {
    case 'order.paid':
      await handleOrderPaid(data);
      break;
    case 'order.payment_failed':
      await handleOrderPaymentFailed(data);
      break;
    case 'order.canceled':
      await handleOrderCanceled(data);
      break;
    case 'order.refunded':
      await handleOrderRefunded(data);
      break;
    default:
      console.log(`Evento n√£o tratado: ${eventType}`);
  }
}

// Handler para pagamento aprovado
async function handleOrderPaid(data: any) {
  try {
    const { id: orderId, customer, amount, items } = data;
    
    console.log('Pagamento aprovado:', {
      orderId,
      customerEmail: customer?.email,
      amount,
      items
    });

    // Aqui voc√™ pode:
    // 1. Atualizar o status do pedido no banco de dados
    // 2. Enviar e-mail de confirma√ß√£o para o cliente
    // 3. Ativar a licen√ßa do sistema
    // 4. Registrar logs de auditoria

    // Exemplo de atualiza√ß√£o no banco (adapte conforme sua estrutura)
    /*
    await updateOrderStatus(orderId, 'paid');
    await activateUserLicense(customer.email);
    await sendConfirmationEmail(customer.email, orderId);
    */

    // Log para desenvolvimento
    console.log(`‚úÖ Pedido ${orderId} processado com sucesso`);
    
  } catch (error) {
    console.error('Erro ao processar pagamento aprovado:', error);
    throw error;
  }
}

// Handler para falha no pagamento
async function handleOrderPaymentFailed(data: any) {
  try {
    const { id: orderId, customer, refuse_reason } = data;
    
    console.log('Pagamento falhou:', {
      orderId,
      customerEmail: customer?.email,
      reason: refuse_reason
    });

    // Aqui voc√™ pode:
    // 1. Atualizar o status do pedido para "failed"
    // 2. Enviar e-mail informando sobre a falha
    // 3. Registrar tentativa de pagamento

    console.log(`‚ùå Falha no pagamento do pedido ${orderId}: ${refuse_reason}`);
    
  } catch (error) {
    console.error('Erro ao processar falha de pagamento:', error);
    throw error;
  }
}

// Handler para pedido cancelado
async function handleOrderCanceled(data: any) {
  try {
    const { id: orderId, customer } = data;
    
    console.log('Pedido cancelado:', {
      orderId,
      customerEmail: customer?.email
    });

    // Aqui voc√™ pode:
    // 1. Atualizar o status do pedido para "canceled"
    // 2. Liberar estoque se necess√°rio
    // 3. Enviar e-mail de cancelamento

    console.log(`üö´ Pedido ${orderId} cancelado`);
    
  } catch (error) {
    console.error('Erro ao processar cancelamento:', error);
    throw error;
  }
}

// Handler para reembolso
async function handleOrderRefunded(data: any) {
  try {
    const { id: orderId, customer, amount } = data;
    
    console.log('Reembolso processado:', {
      orderId,
      customerEmail: customer?.email,
      amount
    });

    // Aqui voc√™ pode:
    // 1. Atualizar o status do pedido para "refunded"
    // 2. Desativar licen√ßa do usu√°rio
    // 3. Enviar e-mail de confirma√ß√£o de reembolso

    console.log(`üí∞ Reembolso de R$ ${amount/100} processado para o pedido ${orderId}`);
    
  } catch (error) {
    console.error('Erro ao processar reembolso:', error);
    throw error;
  }
}

export async function POST(request: NextRequest) {
  try {
    // Obter o corpo da requisi√ß√£o
    const body = await request.text();
    const webhookData = JSON.parse(body);

    // Obter headers necess√°rios
    const signature = request.headers.get('x-hub-signature-256');
    const eventType = request.headers.get('x-pagarme-event');

    // Verificar se os headers necess√°rios est√£o presentes
    if (!signature || !eventType) {
      console.error('Headers obrigat√≥rios ausentes:', { signature, eventType });
      return NextResponse.json(
        { error: 'Headers obrigat√≥rios ausentes' },
        { status: 400 }
      );
    }

    // Verificar assinatura do webhook (recomendado para produ√ß√£o)
    const webhookSecret = process.env.PAGARME_WEBHOOK_SECRET;
    if (webhookSecret) {
      const isValidSignature = verifyWebhookSignature(
        body,
        signature.replace('sha256=', ''),
        webhookSecret
      );

      if (!isValidSignature) {
        console.error('Assinatura do webhook inv√°lida');
        return NextResponse.json(
          { error: 'Assinatura inv√°lida' },
          { status: 401 }
        );
      }
    }

    // Log do evento recebido
    console.log('Webhook recebido:', {
      event: eventType,
      timestamp: new Date().toISOString(),
      data: webhookData
    });

    // Processar o evento
    await processWebhookEvent(eventType, webhookData);

    // Retornar sucesso
    return NextResponse.json(
      { 
        success: true, 
        message: 'Webhook processado com sucesso',
        event: eventType 
      },
      { status: 200 }
    );

  } catch (error) {
    console.error('Erro ao processar webhook:', error);
    
    return NextResponse.json(
      { 
        error: 'Erro interno do servidor',
        message: error instanceof Error ? error.message : 'Erro desconhecido'
      },
      { status: 500 }
    );
  }
}

// M√©todo GET para verificar se o endpoint est√° funcionando
export async function GET() {
  return NextResponse.json({
    message: 'Webhook endpoint da Pagar.me est√° funcionando',
    timestamp: new Date().toISOString(),
    status: 'active'
  });
}