import { NextRequest, NextResponse } from 'next/server';

// Configura√ß√£o do Backend SOFIA
const SOFIA_BACKEND_URL = 'http://localhost:3001/api';

export async function POST(request: NextRequest) {
  try {
    console.log('üöÄ Iniciando valida√ß√£o de sinal...');
    
    // Verificar autoriza√ß√£o
    const authHeader = request.headers.get('authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return NextResponse.json(
        { error: 'Token de autoriza√ß√£o necess√°rio' },
        { status: 401 }
      );
    }

    const body = await request.json();
    console.log('üìù Dados recebidos para valida√ß√£o:', body);

    // Validar sinal no backend SOFIA
    console.log('üîç Enviando valida√ß√£o para o backend SOFIA...');
    
    const response = await fetch(`${SOFIA_BACKEND_URL}/signals/validate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': authHeader,
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      console.error('‚ùå Erro ao validar sinal no backend:', response.status, response.statusText);
      const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
      return NextResponse.json(errorData, { status: response.status });
    }

    const validationData = await response.json();
    console.log('‚úÖ Sinal validado no backend SOFIA:', validationData);
    
    return NextResponse.json(validationData);
  } catch (error) {
    console.error('Erro na API de valida√ß√£o de sinais:', error);
    return NextResponse.json(
      { error: 'Erro interno do servidor' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  return NextResponse.json({
    message: 'Use POST para validar um sinal',
    endpoint: '/api/signals/validate',
    method: 'POST',
    description: 'Valida um sinal como hit ou miss e calcula o expected_return real',
    parameters: {
      signal_id: 'ID do sinal a ser validado',
      result: 'hit ou miss',
      winning_number: 'N√∫mero que saiu na roleta',
      net_payout: 'Lucro l√≠quido real (opcional, ser√° calculado se n√£o fornecido)'
    }
  });
}